<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Tobias Merz — Senior Developer & GIS / Geodata Expert</title>
        <meta
            name="description"
            content="Tobias Merz — Senior Developer & GIS / Geodata / Web Mapping Expert."
        />

        <link
            rel="icon"
            type="image/png"
            href="./favicon-96x96.png"
            sizes="96x96"
        />
        <link rel="icon" type="image/svg+xml" href="./favicon.svg" />
        <link rel="shortcut icon" href="./favicon.ico" />
        <link
            rel="apple-touch-icon"
            sizes="180x180"
            href="./apple-touch-icon.png"
        />
        <meta
            name="apple-mobile-web-app-title"
            content="Tobias Merz - Homepage"
        />
        <link rel="manifest" href="./site.webmanifest" />

        <style>
            @font-face {
                font-family: "MuseoModerno-regular";
                font-style: normal;
                font-weight: 400;
                font-display: swap;
                src: url("./MuseoModerno-regular-400.woff2") format("woff2");
            }

            @font-face {
                font-family: "MuseoModerno-bold";
                font-style: normal;
                font-weight: 700;
                font-display: swap;
                src: url("./MuseoModerno-regular-700.woff2") format("woff2");
            }

            :root {
                color-scheme: light dark;
                --bg0: #070b18;
                --bg1: #081526;
                --ink: rgba(255, 255, 255, 0.92);
                --muted: rgba(255, 255, 255, 0.68);

                --aqua: #65f5ff;
                --mint: #66ffb2;
                --violet: #b37bff;

                --shadow: 0 30px 120px rgba(0, 0, 0, 0.55);
                --shadow2: 0 10px 30px rgba(0, 0, 0, 0.35);

                --radius-xl: 28px;
                --radius-lg: 20px;
                --radius-md: 14px;

                /* Marker sizes - larger on desktop */
                --pin-size: 68px;
                --pin-main-size: 76px;
                --pin-icon-size: 34px;
            }

            body,
            p {
                font-family: "MuseoModerno-regular", sans-serif;
            }

            h1,
            h2,
            h3,
            h4,
            h5,
            h6 {
                font-family: "MuseoModerno-bold", sans-serif;
                color: rgba(255, 255, 255, 0.95);
            }

            html.light-mode h1,
            html.light-mode h2,
            html.light-mode h3,
            html.light-mode h4,
            html.light-mode h5,
            html.light-mode h6 {
                color: rgba(30, 70, 130, 0.95);
            }

            html.light-mode {
                --bg0: #f8f8fa;
                --bg1: #ffffff;
                --ink: rgba(0, 0, 0, 0.92);
                --muted: rgba(0, 0, 0, 0.68);
                --shadow: 0 30px 120px rgba(0, 0, 0, 0.1);
                --shadow2: 0 10px 30px rgba(0, 0, 0, 0.08);
            }

            * {
                box-sizing: border-box;
            }

            html,
            body {
                height: 100%;
                user-select: none;
            }

            body {
                margin: 0;
                font-family:
                    ui-sans-serif,
                    system-ui,
                    -apple-system,
                    Segoe UI,
                    Roboto,
                    Helvetica,
                    Arial,
                    "Apple Color Emoji",
                    "Segoe UI Emoji";
                color: var(--ink);
                background:
                    radial-gradient(
                        1200px 800px at 15% 15%,
                        rgba(101, 245, 255, 0.14),
                        transparent 55%
                    ),
                    radial-gradient(
                        900px 700px at 85% 20%,
                        rgba(179, 123, 255, 0.12),
                        transparent 55%
                    ),
                    radial-gradient(
                        900px 700px at 65% 90%,
                        rgba(102, 255, 178, 0.09),
                        transparent 55%
                    ),
                    linear-gradient(145deg, var(--bg0), var(--bg1));
                overflow: hidden;
                transition:
                    background 300ms ease,
                    color 300ms ease;
            }

            html.light-mode body {
                background:
                    radial-gradient(
                        1200px 800px at 15% 15%,
                        rgba(200, 230, 255, 0.4),
                        transparent 55%
                    ),
                    radial-gradient(
                        900px 700px at 85% 20%,
                        rgba(230, 200, 255, 0.35),
                        transparent 55%
                    ),
                    radial-gradient(
                        900px 700px at 65% 90%,
                        rgba(200, 255, 230, 0.3),
                        transparent 55%
                    ),
                    linear-gradient(145deg, var(--bg0), var(--bg1));
            }

            /* Subtle animated grain */
            .grain {
                position: fixed;
                inset: -20%;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
                opacity: 0.08;
                mix-blend-mode: overlay;
                pointer-events: none;
                transform: translate3d(0, 0, 0);
                animation: grainMove 10s steps(6) infinite;
                z-index: 2;
            }

            html.light-mode .grain {
                opacity: 0.04;
            }

            @keyframes grainMove {
                0% {
                    transform: translate(-2%, -2%) scale(1.05);
                }
                50% {
                    transform: translate(2%, 1%) scale(1.05);
                }
                100% {
                    transform: translate(-2%, 2%) scale(1.05);
                }
            }

            /* Map canvas layer */
            .map-layer {
                position: fixed;
                inset: 0;
                z-index: 0;
            }

            canvas {
                width: 100%;
                height: 100%;
                display: block;
            }

            /* Glow vignette */
            .vignette {
                position: fixed;
                inset: 0;
                background:
                    radial-gradient(
                        900px 700px at 50% 50%,
                        transparent 35%,
                        rgba(0, 0, 0, 0.35) 100%
                    ),
                    radial-gradient(
                        1400px 900px at 50% 120%,
                        rgba(0, 0, 0, 0.35),
                        transparent 55%
                    );
                pointer-events: none;
                z-index: 1;
                transition: background 300ms ease;
            }

            html.light-mode .vignette {
                background:
                    radial-gradient(
                        900px 700px at 50% 50%,
                        transparent 40%,
                        rgba(0, 0, 0, 0.08) 100%
                    ),
                    radial-gradient(
                        1400px 900px at 50% 120%,
                        rgba(0, 0, 0, 0.05),
                        transparent 55%
                    );
            }

            /* UI overlay */
            .ui {
                position: fixed;
                inset: 0;
                z-index: 3;
                pointer-events: none;
            }

            /* Markers */
            .markers {
                position: absolute;
                inset: 0;
                pointer-events: none;
            }

            .marker {
                position: absolute;
                transform: translate(-50%, -100%);
                pointer-events: auto;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .marker-drag-handle {
                width: 24px;
                height: 24px;
                margin-bottom: 4px;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.15);
                border: 1.5px solid rgba(255, 255, 255, 0.3);
                cursor: grab;
                display: flex;
                align-items: center;
                justify-content: center;
                transition:
                    background 240ms ease,
                    border-color 240ms ease,
                    transform 240ms ease,
                    box-shadow 240ms ease;
                pointer-events: auto;
                flex-shrink: 0;
            }

            .marker-drag-handle:hover {
                background: rgba(255, 255, 255, 0.25);
                border-color: rgba(101, 245, 255, 0.5);
                box-shadow: 0 0 12px rgba(101, 245, 255, 0.3);
            }

            .marker-drag-handle:active {
                cursor: grabbing;
                transform: scale(1.1);
                background: rgba(101, 245, 255, 0.2);
                border-color: rgba(101, 245, 255, 0.7);
            }

            html.light-mode .marker-drag-handle {
                background: rgba(100, 150, 200, 0.15);
                border: 1.5px solid rgba(100, 150, 200, 0.4);
            }

            html.light-mode .marker-drag-handle:hover {
                background: rgba(100, 150, 200, 0.25);
                border-color: rgba(80, 150, 255, 0.6);
                box-shadow: 0 0 12px rgba(80, 150, 255, 0.3);
            }

            html.light-mode .marker-drag-handle:active {
                background: rgba(80, 150, 255, 0.2);
                border-color: rgba(80, 150, 255, 0.8);
            }

            .marker-drag-handle::before {
                content: "";
                width: 6px;
                height: 6px;
                background: rgba(255, 255, 255, 0.7);
                border-radius: 50%;
                box-shadow:
                    0 -6px 0 rgba(255, 255, 255, 0.7),
                    0 6px 0 rgba(255, 255, 255, 0.7),
                    -6px 0 0 rgba(255, 255, 255, 0.7),
                    6px 0 0 rgba(255, 255, 255, 0.7);
            }

            html.light-mode .marker-drag-handle::before {
                background: rgba(100, 150, 200, 0.8);
                box-shadow:
                    0 -6px 0 rgba(100, 150, 200, 0.8),
                    0 6px 0 rgba(100, 150, 200, 0.8),
                    -6px 0 0 rgba(100, 150, 200, 0.8),
                    6px 0 0 rgba(100, 150, 200, 0.8);
            }

            .pin {
                position: relative;
                width: var(--pin-size);
                height: var(--pin-size);
                border-radius: 50% 50% 50% 0;
                transform: rotate(-45deg);
                background: linear-gradient(
                    145deg,
                    rgb(255 255 255 / 21%),
                    rgba(255, 255, 255, 0.08)
                );
                border: 1.5px solid rgba(255, 255, 255, 0.22);
                box-shadow:
                    0 18px 45px rgba(0, 0, 0, 0.35),
                    0 0 0 1px rgba(0, 0, 0, 0.15) inset;
                backdrop-filter: blur(12px);
                transition:
                    transform 240ms ease,
                    box-shadow 240ms ease,
                    background 300ms ease,
                    border-color 300ms ease;
            }

            html.light-mode .pin {
                background: linear-gradient(
                    145deg,
                    rgba(255, 255, 255, 0.65),
                    rgba(220, 240, 255, 0.45)
                );
                border: 1.5px solid rgba(100, 150, 200, 0.35);
                box-shadow:
                    0 18px 45px rgba(0, 0, 0, 0.08),
                    0 0 0 1px rgba(100, 150, 200, 0.15) inset;
                backdrop-filter: blur(12px);
            }

            .pin::after {
                content: "";
                position: absolute;
                left: 50%;
                top: 50%;
                width: 80%;
                height: 80%;
                border-radius: 999px;
                opacity: 0.2;
                transform: translate(-50%, -50%);
                background: radial-gradient(
                    circle at 30% 30%,
                    rgba(255, 255, 255, 0.95),
                    rgba(101, 245, 255, 0.85)
                );
                box-shadow: 0 0 20px rgba(101, 245, 255, 0.65);
                transition:
                    background 300ms ease,
                    box-shadow 300ms ease;
            }

            html.light-mode .pin::after {
                background: radial-gradient(
                    circle at 30% 30%,
                    rgba(100, 180, 255, 0.95),
                    rgba(80, 150, 255, 0.75)
                );
                box-shadow: 0 0 20px rgba(80, 150, 255, 0.5);
            }

            .pin-icon {
                position: absolute;
                inset: 0;
                display: grid;
                place-items: center;
                transform: rotate(45deg);
                color: rgba(255, 255, 255, 0.95);
                user-select: none;
                transition: color 300ms ease;
                pointer-events: auto;
            }

            html.light-mode .pin-icon {
                color: rgba(50, 110, 180, 0.95);
            }

            .pin-icon svg {
                width: var(--pin-icon-size);
                height: var(--pin-icon-size);
                stroke: currentColor;
                stroke-width: 1.5;
                fill: none;
                stroke-linecap: round;
                stroke-linejoin: round;
                filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            }

            html.light-mode .pin-icon svg {
                filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
            }

            .marker:hover .pin {
                transform: rotate(-45deg) scale(1.12);
                box-shadow:
                    0 24px 70px rgba(0, 0, 0, 0.45),
                    0 0 50px rgba(101, 245, 255, 0.28);
            }

            html.light-mode .marker:hover .pin {
                box-shadow:
                    0 24px 70px rgba(0, 0, 0, 0.1),
                    0 0 50px rgba(80, 150, 255, 0.25);
            }

            .tooltip {
                position: absolute;
                left: 50%;
                top: -14px;
                transform: translate(-50%, -100%);
                padding: 8px 10px;
                border-radius: 10px;
                background: rgba(10, 14, 28, 0.72);
                border: 1px solid rgba(255, 255, 255, 0.12);
                color: rgba(255, 255, 255, 0.9);
                font-size: 12px;
                white-space: nowrap;
                opacity: 0;
                pointer-events: none;
                backdrop-filter: blur(10px);
                transition:
                    opacity 160ms ease,
                    transform 160ms ease,
                    background 300ms ease,
                    border-color 300ms ease,
                    color 300ms ease;
                box-shadow: 0 14px 40px rgba(0, 0, 0, 0.45);
            }

            html.light-mode .tooltip {
                background: rgba(255, 255, 255, 0.95);
                border: 1px solid rgba(100, 150, 200, 0.3);
                color: rgba(30, 60, 100, 0.95);
                box-shadow: 0 14px 40px rgba(0, 0, 0, 0.12);
            }

            .marker:hover .tooltip {
                opacity: 1;
                transform: translate(-50%, -120%);
            }

            /* Drag handle for edit mode */
            .drag-handle {
                position: absolute;
                bottom: -12px;
                left: 50%;
                transform: translate(-50%, 100%);
                width: 32px;
                height: 32px;
                background: rgba(101, 245, 255, 0.15);
                border: 2px solid rgba(101, 245, 255, 0.5);
                border-radius: 50%;
                cursor: move;
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 10;
                transition: all 200ms ease;
                backdrop-filter: blur(8px);
            }

            html.light-mode .drag-handle {
                background: rgba(80, 150, 255, 0.2);
                border-color: rgba(80, 150, 255, 0.6);
            }

            /* SVG icon styling */
            .drag-handle svg {
                display: block;
                color: rgba(101, 245, 255, 0.9);
                filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
            }

            html.light-mode .drag-handle svg {
                color: rgba(80, 150, 255, 0.9);
                filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.15));
            }

            .marker.edit-mode .drag-handle {
                display: flex;
            }

            .drag-handle:hover {
                background: rgba(101, 245, 255, 0.25);
                border-color: rgba(101, 245, 255, 0.7);
                transform: translate(-50%, 100%) scale(1.1);
            }

            html.light-mode .drag-handle:hover {
                background: rgba(80, 150, 255, 0.3);
                border-color: rgba(80, 150, 255, 0.8);
            }

            /* Main card marker */
            .main {
                transform: translate(-50%, -50%);
                pointer-events: auto;
                z-index: 1;
                flex-direction: column;
                display: flex;
            }

            .main-wrapper {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0;
            }

            .main .pin {
                width: var(--pin-main-size);
                height: var(--pin-main-size);
                transform: rotate(-45deg);
                margin: 0;
                flex-shrink: 0;
                border-radius: 50% 50% 50% 0;
            }

            .card {
                pointer-events: auto;
                width: min(560px, calc(100vw - 28px));
                border-radius: var(--radius-xl);
                background: linear-gradient(
                    180deg,
                    rgba(255, 255, 255, 0.12),
                    rgba(255, 255, 255, 0.06)
                );
                border: 1px solid rgba(255, 255, 255, 0.14);
                box-shadow: var(--shadow);
                backdrop-filter: blur(16px);
                position: relative;
                margin-top: -8px;
                transition:
                    background 300ms ease,
                    border-color 300ms ease,
                    box-shadow 300ms ease;
            }

            html.light-mode .card {
                background: linear-gradient(
                    180deg,
                    rgba(255, 255, 255, 0.7),
                    rgba(240, 250, 255, 0.5)
                );
                border: 1px solid rgba(100, 150, 200, 0.2);
                backdrop-filter: blur(16px);
            }

            .card::before,
            .legend::before {
                content: "";
                position: absolute;
                inset: -2px;
                background:
                    radial-gradient(
                        900px 400px at 20% 0%,
                        rgba(101, 245, 255, 0.22),
                        transparent 55%
                    ),
                    radial-gradient(
                        800px 350px at 85% 20%,
                        rgba(179, 123, 255, 0.18),
                        transparent 55%
                    );
                opacity: 0.4;
                filter: blur(20px);
                pointer-events: none;
                transition: opacity 300ms ease;
            }

            html.light-mode .card::before {
                opacity: 0.08;
            }

            html.light-mode .legend::before {
                opacity: 0;
            }

            .card-inner {
                position: relative;
                padding: 22px;
            }

            .name {
                font-size: 4.5em;
                letter-spacing: 0.06em;
                line-height: 1.05;
                margin: 0;
            }

            .role {
                margin: 6px 0 0;
                font-size: 14px;
                letter-spacing: 0.12em;
                text-transform: uppercase;
                color: rgba(255, 255, 255, 0.75);
                transition: color 300ms ease;
            }

            html.light-mode .role {
                color: rgba(60, 100, 150, 0.8);
            }

            .tagline {
                margin: 12px 0 0;
                font-size: 15px;
                color: rgba(255, 255, 255, 0.78);
                transition: color 300ms ease;
            }

            html.light-mode .tagline {
                color: rgba(50, 80, 120, 0.85);
            }

            .chips {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-top: 16px;
            }

            .chip {
                font-size: 12px;
                letter-spacing: 0.06em;
                text-transform: uppercase;
                padding: 8px 10px;
                border-radius: 999px;
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.12);
                color: rgba(255, 255, 255, 0.82);
                transition:
                    background 300ms ease,
                    border-color 300ms ease,
                    color 300ms ease;
            }

            html.light-mode .chip {
                background: rgba(100, 150, 200, 0.12);
                border: 1px solid rgba(100, 150, 200, 0.25);
                color: rgba(40, 80, 130, 0.9);
            }

            .chip strong {
                font-weight: 700;
                color: rgba(255, 255, 255, 0.95);
                transition: color 300ms ease;
            }

            html.light-mode .chip strong {
                color: rgba(30, 70, 130, 0.95);
            }

            .divider {
                height: 1px;
                background: linear-gradient(
                    90deg,
                    transparent,
                    rgba(255, 255, 255, 0.18),
                    transparent
                );
                margin: 16px 0;
                transition: background 300ms ease;
            }

            html.light-mode .divider {
                background: linear-gradient(
                    90deg,
                    transparent,
                    rgba(100, 150, 200, 0.2),
                    transparent
                );
            }

            .cta {
                display: flex;
                gap: 12px;
                flex-wrap: wrap;
                align-items: center;
            }

            .btn {
                pointer-events: auto;
                appearance: none;
                border: 1px solid rgba(255, 255, 255, 0.14);
                background: rgba(255, 255, 255, 0.08);
                color: rgba(255, 255, 255, 0.92);
                padding: 10px 12px;
                border-radius: 12px;
                font-weight: 600;
                font-size: 13px;
                letter-spacing: 0.02em;
                display: inline-flex;
                align-items: center;
                gap: 10px;
                text-decoration: none;
                transition:
                    transform 160ms ease,
                    background 160ms ease,
                    border-color 160ms ease,
                    color 300ms ease;
                backdrop-filter: blur(10px);
            }

            html.light-mode .btn {
                border: 1px solid rgba(100, 150, 200, 0.3);
                background: rgba(100, 150, 200, 0.1);
                color: rgba(30, 70, 130, 0.92);
            }

            .btn:hover {
                transform: translateY(-2px);
                border-color: rgba(101, 245, 255, 0.35);
                background: rgba(101, 245, 255, 0.1);
            }

            html.light-mode .btn:hover {
                border-color: rgba(80, 150, 255, 0.4);
                background: rgba(100, 180, 255, 0.15);
            }

            .btn:focus-visible {
                outline: 2px solid rgba(101, 245, 255, 0.5);
                outline-offset: 2px;
            }

            html.light-mode .btn:focus-visible {
                outline: 2px solid rgba(100, 150, 255, 0.5);
            }

            .btn .kbd {
                font-size: 11px;
                font-weight: 700;
                letter-spacing: 0.06em;
                padding: 3px 6px;
                border-radius: 8px;
                background: rgba(0, 0, 0, 0.18);
                border: 1px solid rgba(255, 255, 255, 0.12);
                color: rgba(255, 255, 255, 0.75);
                transition:
                    background 300ms ease,
                    border-color 300ms ease,
                    color 300ms ease;
            }

            html.light-mode .btn .kbd {
                background: rgba(100, 150, 200, 0.15);
                border: 1px solid rgba(100, 150, 200, 0.25);
                color: rgba(40, 80, 130, 0.8);
            }

            .footer-note {
                margin-top: 12px;
                font-size: 12px;
                color: rgba(255, 255, 255, 0.55);
                transition: color 300ms ease;
            }

            html.light-mode .footer-note {
                color: rgba(80, 110, 150, 0.65);
            }

            /* Simplified legend */
            .legend {
                position: absolute;
                left: 14px;
                bottom: 14px;
                padding: 10px 12px;
                border-radius: 14px;
                background: rgba(255, 255, 255, 0.06);
                border: 1px solid rgba(255, 255, 255, 0.1);
                backdrop-filter: blur(10px);
                box-shadow: var(--shadow2);
                pointer-events: auto;
                max-width: min(320px, calc(100vw - 28px));
                transition:
                    background 300ms ease,
                    border-color 300ms ease,
                    box-shadow 300ms ease;
            }

            html.light-mode .legend {
                background: rgb(255 255 255 / 53%);
                border: 1px solid rgba(100, 150, 200, 0.25);
                backdrop-filter: blur(2px);
            }

            .legend-title {
                font-size: 12px;
                letter-spacing: 0.08em;
                text-transform: uppercase;
                color: rgba(255, 255, 255, 0.72);
                margin: 0 0 8px;
                transition: color 300ms ease;
            }

            html.light-mode .legend-title {
                color: rgba(60, 100, 150, 0.8);
            }

            .legend-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px 12px;
            }

            .legend-item {
                display: grid;
                grid-template-columns: 14px 1fr;
                gap: 10px;
                align-items: center;
                color: rgba(255, 255, 255, 0.72);
                font-size: 12px;
                min-width: 0;
                transition: color 300ms ease;
            }

            html.light-mode .legend-item {
                color: rgba(50, 80, 120, 0.85);
            }

            .swatch {
                width: 14px;
                height: 14px;
                border-radius: 4px;
                border: 1px solid rgba(255, 255, 255, 0.12);
                transition:
                    background 300ms ease,
                    border-color 300ms ease;
            }

            html.light-mode .swatch {
                border: 1px solid rgba(100, 150, 200, 0.3);
            }

            .swatch.street {
                background: rgba(101, 245, 255, 0.24);
            }

            html.light-mode .swatch.street {
                background: rgba(100, 200, 255, 0.6);
            }

            .swatch.building {
                background: rgba(160, 210, 255, 0.14);
            }

            html.light-mode .swatch.building {
                background: rgba(150, 190, 255, 0.55);
            }

            .swatch.park {
                background: rgba(100, 220, 150, 0.22);
            }

            html.light-mode .swatch.park {
                background: rgba(100, 200, 130, 0.65);
            }

            .swatch.river {
                background: rgba(150, 200, 255, 0.24);
            }

            html.light-mode .swatch.river {
                background: rgba(120, 180, 255, 0.6);
            }

            /* Tablet/medium screens */
            @media (max-width: 1024px) {
                :root {
                    /* Medium marker sizes on tablets */
                    --pin-size: 56px;
                    --pin-main-size: 64px;
                    --pin-icon-size: 28px;
                }
            }

            /* Mobile adjustments */
            @media (max-width: 600px) {
                :root {
                    /* Smaller marker sizes on mobile */
                    --pin-size: 34px;
                    --pin-main-size: 40px;
                    --pin-icon-size: 18px;
                }

                .card {
                    width: calc(100vw - 20px);
                    border-radius: 22px;
                    margin-top: -6px;
                }

                .card-inner {
                    padding: 18px;
                }

                .name {
                    font-size: 2.6em;
                }

                .role {
                    font-size: 12px;
                    letter-spacing: 0.1em;
                }

                .tagline {
                    /*display: none;*/
                }

                .chips {
                    display: none;
                }

                .divider {
                    margin: 12px 0;
                }

                .cta {
                    gap: 10px;
                }

                .btn {
                    padding: 10px 10px;
                    border-radius: 12px;
                }

                .btn .kbd {
                    display: none;
                }

                .legend {
                    left: 10px;
                    bottom: 10px;
                    right: 10px;
                    padding: 8px 10px;
                    border-radius: 12px;
                    max-width: none;
                    width: auto;
                }

                .legend-title {
                    font-size: 10px;
                    margin: 0 0 6px;
                }

                .legend-grid {
                    grid-template-columns: repeat(4, 1fr);
                    gap: 6px 8px;
                }

                .legend-item {
                    font-size: 11px;
                    gap: 6px;
                }

                .swatch {
                    width: 12px;
                    height: 12px;
                }
            }

            /* Landscape mode on small screens */
            @media (max-width: 900px) and (max-height: 500px) {
                :root {
                    /* Smaller markers in landscape */
                    --pin-size: 36px;
                    --pin-main-size: 40px;
                    --pin-icon-size: 18px;
                }

                .card {
                    max-width: 50vw;
                    border-radius: 18px;
                    margin-top: -4px;
                    max-height: 50vh;
                }

                .card-inner {
                    padding: 14px;
                }

                .name {
                    font-size: 2em;
                }

                .role {
                    font-size: 10px;
                    letter-spacing: 0.08em;
                    margin: 3px 0 0;
                }

                .tagline {
                    font-size: 13px;
                    margin: 8px 0 0;
                }

                .chips {
                    display: none;
                }

                .divider {
                    margin: 8px 0;
                }

                .cta {
                    gap: 8px;
                    flex-wrap: nowrap;
                }

                .btn {
                    padding: 8px 10px;
                    font-size: 11px;
                    border-radius: 10px;
                }

                .btn .kbd {
                    display: none;
                }

                .footer-note {
                    display: none;
                }

                .legend {
                    left: 8px;
                    bottom: 8px;
                    right: auto;
                    padding: 6px 8px;
                    border-radius: 10px;
                    max-width: 160px;
                }

                .legend-title {
                    font-size: 9px;
                    margin: 0 0 4px;
                }

                .legend-grid {
                    grid-template-columns: 1fr;
                    gap: 3px;
                }

                .legend-item {
                    font-size: 9px;
                    gap: 5px;
                }

                .swatch {
                    width: 10px;
                    height: 10px;
                }
            }

            /* Reduced motion */
            @media (prefers-reduced-motion: reduce) {
                .grain {
                    animation: none;
                }
                .marker:hover .pin {
                    transform: rotate(-45deg);
                }
                .btn:hover {
                    transform: none;
                }
                body {
                    transition: none;
                }
                .vignette,
                .pin,
                .tooltip,
                .card,
                .btn,
                .legend,
                .divider,
                .chip,
                .role,
                .tagline,
                .footer-note,
                .legend-title,
                .legend-item,
                .swatch {
                    transition: none;
                }
            }
        </style>
    </head>
    <body>
        <div class="map-layer">
            <canvas id="map"></canvas>
        </div>

        <div class="vignette"></div>
        <div class="grain"></div>

        <div class="ui">
            <div class="markers" id="markers">
                <!-- MAIN CONTENT: available without JS -->
                <div class="marker main" style="left: 50%; top: 50%">
                    <div class="main-wrapper">
                        <div class="card" role="region" aria-label="Profile">
                            <div class="card-inner">
                                <h1 class="name">Tobias Merz</h1>
                                <div class="role">
                                    Senior Developer • GIS / Geodata • Web
                                    Mapping
                                </div>
                                <p class="tagline">
                                    Building fast, reliable web apps and mapping
                                    experiences — from geodata pipelines to
                                    interactive cartography.
                                </p>

                                <div class="chips" aria-label="Skills">
                                    <span class="chip"
                                        ><strong>GIS</strong> &amp; Spatial
                                        Analysis</span
                                    >
                                    <span class="chip"
                                        ><strong>Web Maps</strong>
                                        (Vector/Tile)</span
                                    >
                                    <span class="chip"
                                        ><strong>APIs</strong> &amp; Data
                                        Engineering</span
                                    >
                                    <span class="chip"
                                        ><strong>Frontend</strong>
                                        Performance</span
                                    >
                                </div>

                                <div class="divider"></div>

                                <div class="cta">
                                    <a class="btn" href="mailto:info@tmerz.com">
                                        <span>Mail</span>
                                    </a>

                                    <!-- Optional: make social links always available without JS -->
                                    <a
                                        class="btn"
                                        href="https://github.com/tobi238"
                                        target="_blank"
                                        rel="noopener"
                                    >
                                        <span>GitHub</span>
                                    </a>
                                    <a
                                        class="btn"
                                        href="https://www.linkedin.com/in/tobiasmerz"
                                        target="_blank"
                                        rel="noopener"
                                    >
                                        <span>LinkedIn</span>
                                    </a>
                                    <a
                                        class="btn"
                                        href="https://www.xing.com/profile/Tobias_Merz14/cv"
                                        target="_blank"
                                        rel="noopener"
                                    >
                                        <span>Xing</span>
                                    </a>
                                </div>

                                <noscript>
                                    <div class="footer-note">
                                        JavaScript is disabled — the interactive
                                        map and floating markers are
                                        unavailable, but you can still use the
                                        links above.
                                    </div>
                                </noscript>

                                <div class="footer-note">
                                    Tip: Hover markers to reveal labels. The
                                    city regenerates on each load.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- /MAIN CONTENT -->
            </div>

            <div class="legend" aria-label="Legend">
                <div class="legend-title">Legend</div>
                <div class="legend-grid">
                    <div class="legend-item">
                        <span class="swatch street"></span><span>Street</span>
                    </div>
                    <div class="legend-item">
                        <span class="swatch building"></span
                        ><span>Building</span>
                    </div>
                    <div class="legend-item">
                        <span class="swatch park"></span><span>Park</span>
                    </div>
                    <div class="legend-item">
                        <span class="swatch river"></span><span>River</span>
                    </div>
                </div>
            </div>
        </div>

        <script>
            /**
             * Single-file landing page.
             * Generation order enforced:
             *   River -> Roads -> Buildings -> Parks
             */

            const canvas = document.getElementById("map");
            const ctx = canvas.getContext("2d", { alpha: true });
            const markersEl = document.getElementById("markers");

            // SVG Icons - larger and more visible
            const ICONS = {
                mail: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="20" height="16" rx="2" ry="2"/><path d="M2 6l10 7 10-7" fill="none"/></svg>`,
                github: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12c0 4.42 2.87 8.17 6.84 9.49.5.09.68-.22.68-.48v-1.7c-2.78.6-3.37-1.34-3.37-1.34-.45-1.16-1.11-1.47-1.11-1.47-.91-.62.07-.61.07-.61 1.01.07 1.54 1.04 1.54 1.04.89 1.52 2.34 1.08 2.91.83.09-.65.35-1.09.63-1.34-2.22-.25-4.56-1.11-4.56-4.92 0-1.09.39-1.98 1.03-2.68-.1-.25-.45-1.27.1-2.64 0 0 .84-.27 2.75 1.02.8-.22 1.65-.33 2.5-.33s1.7.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02.55 1.37.2 2.39.1 2.64.64.7 1.03 1.59 1.03 2.68 0 3.82-2.34 4.66-4.57 4.9.36.31.68.93.68 1.88v2.79c0 .27.18.58.69.48C19.14 20.16 22 16.42 22 12c0-5.52-4.48-10-10-10z" fill="none"/></svg>`,
                linkedin: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path
                    d="M8 18H5V8h3v10zm-1.5-11.1a1.74 1.74 0 1 1 0-3.48 1.74 1.74 0 0 1 0 3.48zM18 18h-3v-5.5c0-1.5-1-2.5-2-2.5-1.5 0-2.5 1-2.5 2.5V18h-3V8h2.8v1.3c.4-.6 1.5-1.3 3-1.3 2.5 0 4.7 1.5 4.7 5v5z"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="1.2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>`,
                xing: `<svg
                  viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                >
                  <!-- left chevron -->
                  <path
                    d="M6.2 7.2h3.3l2.1 3.6-2.6 6H5.7l2.7-6.2-2.2-3.4z"
                    stroke="currentColor"
                    stroke-width="1.2"
                    stroke-linejoin="round"
                  />
                  <!-- right 'X' -->
                  <path
                    d="M14.2 4.2h4.1l-4.6 8.1 5.4 9.5H15l-5.4-9.5 4.6-8.1z"
                    stroke="currentColor"
                    stroke-width="1.2"
                    stroke-linejoin="round"
                  />
                </svg>`,
            };

            // ====== MODE MANAGEMENT ======
            let isDarkMode = true;

            function initializeTheme() {
                const savedMode = localStorage.getItem("theme-mode");
                const prefersDark = window.matchMedia(
                    "(prefers-color-scheme: dark)",
                ).matches;

                if (savedMode === "light") {
                    setLightMode();
                } else if (savedMode === "dark") {
                    setDarkMode();
                } else if (prefersDark) {
                    setDarkMode();
                } else {
                    setLightMode();
                }
            }

            function setDarkMode() {
                document.documentElement.classList.remove("light-mode");
                localStorage.setItem("theme-mode", "dark");
                isDarkMode = true;
            }

            function setLightMode() {
                document.documentElement.classList.add("light-mode");
                localStorage.setItem("theme-mode", "light");
                isDarkMode = false;
            }

            function toggleMode() {
                if (isDarkMode) {
                    setLightMode();
                } else {
                    setDarkMode();
                }
            }

            // ====== CONFIG ======
            const CFG = {
                gridSize: 150,
                majorSpacing: 3,

                // River
                riverWidth: 26,
                riverRoadClearance: 22,
                riverParallelBuffer: 30,

                // Road density
                majorProb: 0.92,
                minorProb: 0.7,
                minorDiagProb: 0.55,

                // Buildings / parks
                buildingRoadBuffer: 8,
                parkRoadBuffer: 15,

                // Marker placement
                markerPadding: 80,
                markerMinDistance: 180,

                // Map size multiplier
                mapScale: 2,

                // Animation - minimal subtle movement
                animationDuration: 1500,
            };

            // Social links (replace with your real URLs)
            const LINKS = [
                {
                    name: "Email",
                    icon: "mail",
                    url: "mailto:info@tmerz.com",
                },
                {
                    name: "GitHub",
                    icon: "github",
                    url: "https://github.com/tobi238",
                },
                {
                    name: "LinkedIn",
                    icon: "linkedin",
                    url: "https://www.linkedin.com/in/tobiasmerz",
                },
                {
                    name: "Xing",
                    icon: "xing",
                    url: "https://www.xing.com/profile/Tobias_Merz14/cv",
                },
            ];

            // ====== STATE ======
            let sessionSeed = Math.random() * 100000;
            let river = null;
            let roads = [];
            let buildings = [];
            let parks = [];
            let nodes = {};
            let markerPositions = [];

            // Camera state for panning and zooming
            let camera = { x: 0, y: 0, zoom: 1 };
            let isDragging = false;
            let isDraggingMarker = false;
            let draggedMarkerIndex = -1;
            let dragStart = { x: 0, y: 0 };
            let dragOffset = { x: 0, y: 0 };
            let mapWidth = 0;
            let mapHeight = 0;

            // Zoom constraints
            const MIN_ZOOM = 0.5;
            const MAX_ZOOM = 3;

            // Pinch zoom state
            let lastPinchDistance = 0;

            // Marker editing state
            let isEditMode = false;
            let draggedMarker = null;
            let markerDragStart = { x: 0, y: 0 };
            let markerWorldStart = { x: 0, y: 0 };

            // Check if device is mobile
            const isMobile =
                /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                    navigator.userAgent,
                ) ||
                "ontouchstart" in window ||
                window.innerWidth <= 768;

            // Animation state
            let animationStart = 0;
            let isAnimating = false;
            let animationTarget = { x: 0, y: 0, zoom: 1 };
            let animationInitial = { x: 0, y: 0, zoom: 1 };

            // ====== UTIL ======
            function resize() {
                const dpr = Math.max(
                    1,
                    Math.floor(window.devicePixelRatio || 1),
                );

                // Set map size to be larger than viewport
                mapWidth = Math.floor(window.innerWidth * CFG.mapScale);
                mapHeight = Math.floor(window.innerHeight * CFG.mapScale);

                canvas.width = Math.floor(window.innerWidth * dpr);
                canvas.height = Math.floor(window.innerHeight * dpr);
                canvas.style.width = `${window.innerWidth}px`;
                canvas.style.height = `${window.innerHeight}px`;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                // Center camera on initial load
                camera.x = -(mapWidth - window.innerWidth) / 2;
                camera.y = -(mapHeight - window.innerHeight) / 2;
            }

            function prand(seed) {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            }

            function smoothNoise(x, y) {
                const xi = Math.floor(x);
                const yi = Math.floor(y);
                const xf = x - xi;
                const yf = y - yi;

                const n00 = prand(
                    (xi * 73856093) ^ (yi * 19349663) ^ sessionSeed,
                );
                const n10 = prand(
                    ((xi + 1) * 73856093) ^ (yi * 19349663) ^ sessionSeed,
                );
                const n01 = prand(
                    (xi * 73856093) ^ ((yi + 1) * 19349663) ^ sessionSeed,
                );
                const n11 = prand(
                    ((xi + 1) * 73856093) ^ ((yi + 1) * 19349663) ^ sessionSeed,
                );

                const u = xf * xf * (3 - 2 * xf);
                const v = yf * yf * (3 - 2 * yf);

                const nx0 = n00 * (1 - u) + n10 * u;
                const nx1 = n01 * (1 - u) + n11 * u;
                return nx0 * (1 - v) + nx1 * v;
            }

            function clamp(v, a, b) {
                return Math.max(a, Math.min(b, v));
            }

            function dist(ax, ay, bx, by) {
                const dx = ax - bx;
                const dy = ay - by;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function clampToScreen(x, y, pad) {
                return {
                    x: clamp(x, pad, mapWidth - pad),
                    y: clamp(y, pad, mapHeight - pad),
                };
            }

            function isPointInExclusionZone(x, y, mainBounds, legendBounds) {
                // Check distance from main card
                if (
                    dist(x, y, mainBounds.centerX, mainBounds.centerY) <
                    mainBounds.radius
                ) {
                    return true;
                }

                // Check if marker overlaps with legend
                if (doesMarkerOverlapLegend(x, y, legendBounds)) {
                    return true;
                }

                return false;
            }

            function getLegendBounds() {
                const legendEl = document.querySelector(".legend");
                if (!legendEl) {
                    return {
                        left: -1000,
                        right: -900,
                        top: -1000,
                        bottom: -900,
                    };
                }

                const rect = legendEl.getBoundingClientRect();
                const padding = 10;

                return {
                    left: rect.left - padding,
                    right: rect.right + padding,
                    top: rect.top - padding,
                    bottom: rect.bottom + padding,
                };
            }

            function getMainCardBounds() {
                const cardEl = document.querySelector(".card");
                if (!cardEl) {
                    // Fallback to fixed radius if card not found (centered in map world)
                    return {
                        centerX: mapWidth / 2,
                        centerY: mapHeight / 2,
                        radius: 340,
                    };
                }

                const rect = cardEl.getBoundingClientRect();
                const pinEl = document.querySelector(".main .pin");
                const pinHeight = pinEl ? pinEl.offsetHeight : 60;

                // Add padding around the card + pin
                const padding = 40;

                // Calculate the bounding circle that encompasses the card and pin
                // Main card is always at the center of the map in world coordinates
                const centerX = mapWidth / 2;
                const centerY = mapHeight / 2;

                // The card is centered, so we need to account for:
                // - Half the card width/height
                // - The pin above it
                // - Extra padding
                const cardHalfWidth = rect.width / 2;
                const cardHalfHeight = rect.height / 2;

                // Use the larger dimension to create a circular exclusion zone
                const radius =
                    Math.max(
                        Math.sqrt(
                            cardHalfWidth * cardHalfWidth +
                                cardHalfHeight * cardHalfHeight,
                        ),
                        cardHalfHeight + pinHeight,
                    ) + padding;

                return { centerX, centerY, radius };
            }

            function getPinSize() {
                // Get current pin size from CSS variable
                const pinSize =
                    parseInt(
                        getComputedStyle(document.documentElement)
                            .getPropertyValue("--pin-size")
                            .trim(),
                    ) || 68;
                return pinSize;
            }

            function doesMarkerOverlapLegend(x, y, legendBounds) {
                const pinSize = getPinSize();
                const markerRadius = pinSize / 2;

                // Check if the marker circle intersects with the legend rectangle
                // Find the closest point on the rectangle to the marker center
                const closestX = Math.max(
                    legendBounds.left,
                    Math.min(x, legendBounds.right),
                );
                const closestY = Math.max(
                    legendBounds.top,
                    Math.min(y, legendBounds.bottom),
                );

                // Calculate distance from marker center to closest point
                const dx = x - closestX;
                const dy = y - closestY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Add a small buffer
                return distance < markerRadius + 10;
            }

            // ====== EASING ======
            function easeOutQuad(t) {
                return 1 - (1 - t) * (1 - t);
            }

            // ====== MAP PRIMITIVES ======
            class River {
                constructor() {
                    this.points = [];
                    this.width = CFG.riverWidth;
                    this.isVertical = Math.random() > 0.5;
                    this.generate();
                }

                generate() {
                    this.points = [];
                    const step = 15;
                    const maxMeander = 46;

                    let x = this.isVertical
                        ? mapWidth * (0.3 + Math.random() * 0.4)
                        : -50;
                    let y = this.isVertical
                        ? -50
                        : mapHeight * (0.3 + Math.random() * 0.4);

                    let meander = 0;

                    if (this.isVertical) {
                        while (y < mapHeight + 100) {
                            this.points.push({ x, y });
                            meander += (Math.random() - 0.5) * 15;
                            meander = clamp(meander, -maxMeander, maxMeander);
                            x += meander * 0.12;
                            x = clamp(x, 60, mapWidth - 60);
                            y += step;
                        }
                    } else {
                        while (x < mapWidth + 100) {
                            this.points.push({ x, y });
                            meander += (Math.random() - 0.5) * 15;
                            meander = clamp(meander, -maxMeander, maxMeander);
                            y += meander * 0.12;
                            y = clamp(y, 60, mapHeight - 60);
                            x += step;
                        }
                    }
                }

                distanceTo(px, py) {
                    let min = Infinity;
                    for (const p of this.points) {
                        const d = dist(px, py, p.x, p.y);
                        if (d < min) min = d;
                    }
                    return min;
                }

                isNear(px, py, buffer) {
                    return this.distanceTo(px, py) < buffer;
                }

                doesLineCross(
                    x1,
                    y1,
                    x2,
                    y2,
                    clearance = CFG.riverRoadClearance,
                ) {
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len === 0) return false;

                    const samples = Math.max(6, Math.floor(len / 12));
                    const threshold = this.width / 2 + clearance;

                    for (let i = 0; i <= samples; i++) {
                        const t = i / samples;
                        const px = x1 + t * dx;
                        const py = y1 + t * dy;
                        if (this.distanceTo(px, py) < threshold) return true;
                    }
                    return false;
                }

                isLineParallel(
                    x1,
                    y1,
                    x2,
                    y2,
                    buffer = CFG.riverParallelBuffer,
                ) {
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len === 0) return false;

                    let near = 0;
                    const samples = Math.max(6, Math.floor(len / 16));
                    for (let i = 0; i <= samples; i++) {
                        const t = i / samples;
                        const px = x1 + t * dx;
                        const py = y1 + t * dy;
                        if (this.isNear(px, py, buffer)) near++;
                    }
                    return near / (samples + 1) > 0.5;
                }

                draw(ctx) {
                    if (this.points.length < 2) return;

                    ctx.save();
                    ctx.lineCap = "round";
                    ctx.lineJoin = "round";

                    if (isDarkMode) {
                        ctx.strokeStyle = "rgba(150, 200, 255, 0.10)";
                        ctx.lineWidth = this.width + 22;
                        ctx.beginPath();
                        ctx.moveTo(this.points[0].x, this.points[0].y);
                        for (let i = 1; i < this.points.length; i++) {
                            ctx.lineTo(this.points[i].x, this.points[i].y);
                        }
                        ctx.stroke();

                        ctx.strokeStyle = "rgba(150, 200, 255, 0.22)";
                        ctx.lineWidth = this.width;
                        ctx.beginPath();
                        ctx.moveTo(this.points[0].x, this.points[0].y);
                        for (let i = 1; i < this.points.length; i++) {
                            ctx.lineTo(this.points[i].x, this.points[i].y);
                        }
                        ctx.stroke();

                        ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
                        ctx.lineWidth = Math.max(3, this.width * 0.22);
                        ctx.beginPath();
                        ctx.moveTo(this.points[0].x, this.points[0].y);
                        for (let i = 1; i < this.points.length; i++) {
                            ctx.lineTo(this.points[i].x, this.points[i].y);
                        }
                        ctx.stroke();
                    } else {
                        ctx.strokeStyle = "rgba(80, 130, 200, 0.25)";
                        ctx.lineWidth = this.width + 22;
                        ctx.beginPath();
                        ctx.moveTo(this.points[0].x, this.points[0].y);
                        for (let i = 1; i < this.points.length; i++) {
                            ctx.lineTo(this.points[i].x, this.points[i].y);
                        }
                        ctx.stroke();

                        ctx.strokeStyle = "rgba(60, 110, 180, 0.5)";
                        ctx.lineWidth = this.width;
                        ctx.beginPath();
                        ctx.moveTo(this.points[0].x, this.points[0].y);
                        for (let i = 1; i < this.points.length; i++) {
                            ctx.lineTo(this.points[i].x, this.points[i].y);
                        }
                        ctx.stroke();

                        ctx.strokeStyle = "rgba(40, 80, 140, 0.3)";
                        ctx.lineWidth = Math.max(3, this.width * 0.22);
                        ctx.beginPath();
                        ctx.moveTo(this.points[0].x, this.points[0].y);
                        for (let i = 1; i < this.points.length; i++) {
                            ctx.lineTo(this.points[i].x, this.points[i].y);
                        }
                        ctx.stroke();
                    }

                    ctx.restore();
                }
            }

            class Node {
                constructor(gridX, gridY) {
                    this.gridX = gridX;
                    this.gridY = gridY;

                    const baseX = gridX * CFG.gridSize;
                    const baseY = gridY * CFG.gridSize;

                    const n1 = smoothNoise(gridX * 0.5, gridY * 0.5);
                    const n2 = smoothNoise(
                        gridX * 0.5 + 100,
                        gridY * 0.5 + 100,
                    );

                    this.x = baseX + (n1 - 0.5) * 100;
                    this.y = baseY + (n2 - 0.5) * 100;
                }
            }

            class Road {
                constructor(a, b, type) {
                    this.a = a;
                    this.b = b;
                    this.type = type;
                    this.path = [];
                    this.dots = [];
                    this.makePath();
                    this.makeDots();
                }

                makePath() {
                    this.path = [];
                    if (this.type === "major") {
                        this.path.push({ x: this.a.x, y: this.a.y });
                        this.path.push({ x: this.b.x, y: this.b.y });
                        return;
                    }

                    const dx = this.b.x - this.a.x;
                    const dy = this.b.y - this.a.y;
                    const d = Math.sqrt(dx * dx + dy * dy) || 1;

                    const seed =
                        (this.a.gridX * 73856093) ^
                        (this.a.gridY * 19349663) ^
                        (this.b.gridX * 83492791) ^
                        (this.b.gridY * 12345677) ^
                        sessionSeed;

                    const px = -dy / d;
                    const py = dx / d;
                    const curve = (prand(seed) - 0.5) * d * 0.38;

                    const cx = this.a.x + dx / 2 + px * curve;
                    const cy = this.a.y + dy / 2 + py * curve;

                    const steps = Math.max(5, Math.floor(d / 18));
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        const mt = 1 - t;
                        const x =
                            mt * mt * this.a.x +
                            2 * mt * t * cx +
                            t * t * this.b.x;
                        const y =
                            mt * mt * this.a.y +
                            2 * mt * t * cy +
                            t * t * this.b.y;
                        this.path.push({ x, y });
                    }

                    this.path[0] = { x: this.a.x, y: this.a.y };
                    this.path[this.path.length - 1] = {
                        x: this.b.x,
                        y: this.b.y,
                    };
                }

                makeDots() {
                    const count =
                        this.type === "major"
                            ? Math.floor(Math.random() * 3) + 3
                            : Math.floor(Math.random() * 2) + 1;

                    for (let i = 0; i < count; i++) {
                        this.dots.push({
                            t: Math.random(),
                            v:
                                (Math.random() * 0.0008 + 0.0003) *
                                (this.type === "major" ? 1.25 : 1),
                            r: Math.random() * 1.5 + 0.8,
                        });
                    }
                }

                step() {
                    for (const dot of this.dots) {
                        dot.t += dot.v;
                        if (dot.t > 1) dot.t = 0;
                    }
                }

                pointAt(t) {
                    const idx = t * (this.path.length - 1);
                    const a = Math.floor(idx);
                    const b = Math.min(this.path.length - 1, Math.ceil(idx));
                    const u = idx - a;
                    const p1 = this.path[a];
                    const p2 = this.path[b];
                    return {
                        x: p1.x + (p2.x - p1.x) * u,
                        y: p1.y + (p2.y - p1.y) * u,
                    };
                }

                draw(ctx) {
                    const major = this.type === "major";

                    ctx.save();
                    ctx.lineCap = "round";
                    ctx.lineJoin = "round";

                    if (isDarkMode) {
                        ctx.strokeStyle = "rgba(101, 245, 255, 0.08)";
                        ctx.lineWidth = major ? 8 : 5;
                        ctx.beginPath();
                        ctx.moveTo(this.path[0].x, this.path[0].y);
                        for (let i = 1; i < this.path.length; i++) {
                            ctx.lineTo(this.path[i].x, this.path[i].y);
                        }
                        ctx.stroke();

                        ctx.strokeStyle = "rgba(101, 245, 255, 0.24)";
                        ctx.lineWidth = major ? 2.6 : 1.25;
                        ctx.beginPath();
                        ctx.moveTo(this.path[0].x, this.path[0].y);
                        for (let i = 1; i < this.path.length; i++) {
                            ctx.lineTo(this.path[i].x, this.path[i].y);
                        }
                        ctx.stroke();
                    } else {
                        ctx.strokeStyle = "rgba(100, 160, 220, 0.2)";
                        ctx.lineWidth = major ? 8 : 5;
                        ctx.beginPath();
                        ctx.moveTo(this.path[0].x, this.path[0].y);
                        for (let i = 1; i < this.path.length; i++) {
                            ctx.lineTo(this.path[i].x, this.path[i].y);
                        }
                        ctx.stroke();

                        ctx.strokeStyle = "rgba(60, 130, 200, 0.6)";
                        ctx.lineWidth = major ? 2.6 : 1.25;
                        ctx.beginPath();
                        ctx.moveTo(this.path[0].x, this.path[0].y);
                        for (let i = 1; i < this.path.length; i++) {
                            ctx.lineTo(this.path[i].x, this.path[i].y);
                        }
                        ctx.stroke();
                    }

                    for (const dot of this.dots) {
                        const p = this.pointAt(dot.t);
                        if (isDarkMode) {
                            ctx.fillStyle = "rgba(255, 255, 255, 0.12)";
                        } else {
                            ctx.fillStyle = "rgba(100, 160, 220, 0.2)";
                        }
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, dot.r * 3.2, 0, Math.PI * 2);
                        ctx.fill();

                        if (isDarkMode) {
                            ctx.fillStyle = "rgba(101, 245, 255, 0.65)";
                        } else {
                            ctx.fillStyle = "rgba(80, 140, 200, 0.7)";
                        }
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, dot.r, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();
                }
            }

            class Building {
                constructor(x, y, w, h, a) {
                    this.x = x;
                    this.y = y;
                    this.w = w;
                    this.h = h;
                    this.a = a;
                    this.o = 0.06 + Math.random() * 0.08;
                }

                bounds() {
                    const c = Math.cos(this.a);
                    const s = Math.sin(this.a);
                    const corners = [
                        { x: -this.w / 2, y: -this.h / 2 },
                        { x: this.w / 2, y: -this.h / 2 },
                        { x: this.w / 2, y: this.h / 2 },
                        { x: -this.w / 2, y: this.h / 2 },
                    ].map((p) => ({
                        x: this.x + p.x * c - p.y * s,
                        y: this.y + p.x * s + p.y * c,
                    }));

                    const xs = corners.map((p) => p.x);
                    const ys = corners.map((p) => p.y);
                    return {
                        minX: Math.min(...xs),
                        maxX: Math.max(...xs),
                        minY: Math.min(...ys),
                        maxY: Math.max(...ys),
                    };
                }

                overlapsBuilding(other, buffer = 2) {
                    const a = this.bounds();
                    const b = other.bounds();
                    return !(
                        a.maxX + buffer < b.minX ||
                        b.maxX + buffer < a.minX ||
                        a.maxY + buffer < b.minY ||
                        b.maxY + buffer < a.minY
                    );
                }

                overlapsRoad(roads, buffer = CFG.buildingRoadBuffer) {
                    const r = buffer + Math.max(this.w, this.h) / 2;
                    for (const road of roads) {
                        for (const p of road.path) {
                            if (dist(p.x, p.y, this.x, this.y) < r) return true;
                        }
                    }
                    return false;
                }

                overlapsRiver(river, buffer = 10) {
                    return river.isNear(this.x, this.y, buffer + this.w);
                }

                draw(ctx) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.a);

                    if (isDarkMode) {
                        ctx.fillStyle = `rgba(101, 245, 255, ${this.o * 0.32})`;
                        ctx.fillRect(
                            -this.w / 2 - 2,
                            -this.h / 2 - 2,
                            this.w + 4,
                            this.h + 4,
                        );

                        ctx.fillStyle = `rgba(160, 210, 255, ${this.o})`;
                        ctx.fillRect(-this.w / 2, -this.h / 2, this.w, this.h);
                    } else {
                        ctx.fillStyle = `rgba(100, 160, 220, ${this.o * 0.4})`;
                        ctx.fillRect(
                            -this.w / 2 - 2,
                            -this.h / 2 - 2,
                            this.w + 4,
                            this.h + 4,
                        );

                        ctx.fillStyle = `rgba(80, 140, 200, ${this.o * 1.2})`;
                        ctx.fillRect(-this.w / 2, -this.h / 2, this.w, this.h);
                    }

                    ctx.restore();
                }
            }

            class Park {
                constructor(x, y, w, h, a) {
                    this.x = x;
                    this.y = y;
                    this.w = w;
                    this.h = h;
                    this.a = a;
                    this.o = 0.07 + Math.random() * 0.06;
                }

                bounds() {
                    const c = Math.cos(this.a);
                    const s = Math.sin(this.a);
                    const corners = [
                        { x: -this.w / 2, y: -this.h / 2 },
                        { x: this.w / 2, y: -this.h / 2 },
                        { x: this.w / 2, y: this.h / 2 },
                        { x: -this.w / 2, y: this.h / 2 },
                    ].map((p) => ({
                        x: this.x + p.x * c - p.y * s,
                        y: this.y + p.x * s + p.y * c,
                    }));

                    const xs = corners.map((p) => p.x);
                    const ys = corners.map((p) => p.y);
                    return {
                        minX: Math.min(...xs),
                        maxX: Math.max(...xs),
                        minY: Math.min(...ys),
                        maxY: Math.max(...ys),
                    };
                }

                overlapsPark(other, buffer = 3) {
                    const a = this.bounds();
                    const b = other.bounds();
                    return !(
                        a.maxX + buffer < b.minX ||
                        b.maxX + buffer < a.minX ||
                        a.maxY + buffer < b.minY ||
                        b.maxY + buffer < a.minY
                    );
                }

                overlapsRoad(roads, buffer = CFG.parkRoadBuffer) {
                    const r = buffer + Math.max(this.w, this.h) / 2;
                    for (const road of roads) {
                        for (const p of road.path) {
                            if (dist(p.x, p.y, this.x, this.y) < r) return true;
                        }
                    }
                    return false;
                }

                overlapsRiver(river, buffer = 18) {
                    const b = this.bounds();
                    const cx = (b.minX + b.maxX) / 2;
                    const cy = (b.minY + b.maxY) / 2;
                    return river.isNear(
                        cx,
                        cy,
                        buffer + Math.max(this.w, this.h),
                    );
                }

                overlapsBuildings(buildings, buffer = 3) {
                    const a = this.bounds();
                    for (const bld of buildings) {
                        const b = bld.bounds();
                        const overlap = !(
                            a.maxX + buffer < b.minX ||
                            b.maxX + buffer < a.minX ||
                            a.maxY + buffer < b.minY ||
                            b.maxY + buffer < a.minY
                        );
                        if (overlap) return true;
                    }
                    return false;
                }

                draw(ctx) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.a);

                    if (isDarkMode) {
                        ctx.fillStyle = `rgba(100, 220, 150, ${this.o * 0.35})`;
                        ctx.fillRect(
                            -this.w / 2 - 3,
                            -this.h / 2 - 3,
                            this.w + 6,
                            this.h + 6,
                        );

                        ctx.fillStyle = `rgba(100, 220, 150, ${this.o})`;
                        ctx.fillRect(-this.w / 2, -this.h / 2, this.w, this.h);

                        ctx.strokeStyle = `rgba(255, 255, 255, ${this.o * 0.28})`;
                    } else {
                        ctx.fillStyle = `rgba(100, 180, 120, ${this.o * 0.4})`;
                        ctx.fillRect(
                            -this.w / 2 - 3,
                            -this.h / 2 - 3,
                            this.w + 6,
                            this.h + 6,
                        );

                        ctx.fillStyle = `rgba(80, 160, 100, ${this.o * 1.2})`;
                        ctx.fillRect(-this.w / 2, -this.h / 2, this.w, this.h);

                        ctx.strokeStyle = `rgba(60, 140, 80, ${this.o * 0.4})`;
                    }

                    ctx.lineWidth = 1;
                    for (let i = -this.w / 2; i < this.w / 2; i += 8) {
                        ctx.beginPath();
                        ctx.moveTo(i, -this.h / 2);
                        ctx.lineTo(i + 14, this.h / 2);
                        ctx.stroke();
                    }

                    ctx.restore();
                }
            }

            // ====== GENERATION (ORDER ENFORCED) ======
            function getNode(gx, gy) {
                const k = `${gx},${gy}`;
                if (!nodes[k]) nodes[k] = new Node(gx, gy);
                return nodes[k];
            }

            function isMajorCell(gx, gy) {
                const majorX = Math.abs(gx % CFG.majorSpacing) === 0;
                const majorY = Math.abs(gy % CFG.majorSpacing) === 0;
                return majorX || majorY;
            }

            function addRoadIfAllowed(a, b, type) {
                if (!river) return;

                if (river.isLineParallel(a.x, a.y, b.x, b.y)) return;

                const crosses = river.doesLineCross(a.x, a.y, b.x, b.y);

                if (type === "minor") {
                    if (crosses) return;
                    roads.push(new Road(a, b, type));
                    return;
                }

                if (!crosses) {
                    roads.push(new Road(a, b, type));
                    return;
                }

                const midX = (a.x + b.x) / 2;
                const midY = (a.y + b.y) / 2;

                const nearThreshold = river.width / 2 + CFG.riverRoadClearance;

                const midNear = river.isNear(midX, midY, nearThreshold);
                const aNear = river.isNear(a.x, a.y, nearThreshold);
                const bNear = river.isNear(b.x, b.y, nearThreshold);

                if (midNear && !aNear && !bNear) {
                    roads.push(new Road(a, b, type));
                }
            }

            function generateRiver() {
                river = new River();
            }

            function generateRoads() {
                roads = [];
                nodes = {};

                const cols = Math.ceil(mapWidth / CFG.gridSize) + 2;
                const rows = Math.ceil(mapHeight / CFG.gridSize) + 2;

                for (let gy = -1; gy < rows; gy++) {
                    for (let gx = -1; gx < cols; gx++) {
                        getNode(gx, gy);
                    }
                }

                for (let gy = -1; gy < rows; gy++) {
                    for (let gx = -1; gx < cols; gx++) {
                        const seed =
                            ((gx * 73856093) ^
                                (gy * 19349663) ^
                                sessionSeed) >>>
                            0;
                        const node = getNode(gx, gy);
                        const major = isMajorCell(gx, gy);

                        if (
                            prand(seed) <
                            (major ? CFG.majorProb : CFG.minorProb)
                        ) {
                            addRoadIfAllowed(
                                node,
                                getNode(gx + 1, gy),
                                major ? "major" : "minor",
                            );
                        }

                        if (
                            prand(seed + 500) <
                            (major ? CFG.majorProb : CFG.minorProb)
                        ) {
                            addRoadIfAllowed(
                                node,
                                getNode(gx, gy + 1),
                                major ? "major" : "minor",
                            );
                        }

                        if (!major && prand(seed + 1000) < CFG.minorDiagProb) {
                            const dx = prand(seed + 1500) > 0.5 ? 1 : -1;
                            const dy = prand(seed + 2000) > 0.5 ? 1 : -1;
                            addRoadIfAllowed(
                                node,
                                getNode(gx + dx, gy + dy),
                                "minor",
                            );
                        }
                    }
                }
            }

            function generateBuildings() {
                buildings = [];

                roads.forEach((road, roadIdx) => {
                    const start = road.path[0];
                    const end = road.path[road.path.length - 1];
                    const angle = Math.atan2(end.y - start.y, end.x - start.x);
                    const perp = angle + Math.PI / 2;

                    const count = Math.floor(road.path.length / 3);
                    for (let i = 0; i < count; i++) {
                        const idx = Math.floor(
                            (i / Math.max(1, count)) * (road.path.length - 1),
                        );
                        const p = road.path[idx];

                        const seed = roadIdx * 1000 + i * 100;
                        const side = prand(seed) > 0.5 ? 1 : -1;
                        const offset = 18 + prand(seed + 10) * 8;
                        const w = 12 + prand(seed + 20) * 9;
                        const h = 18 + prand(seed + 30) * 14;

                        const x = p.x + Math.cos(perp) * offset * side;
                        const y = p.y + Math.sin(perp) * offset * side;

                        const b = new Building(
                            x,
                            y,
                            w,
                            h,
                            angle + (prand(seed + 40) > 0.5 ? 0 : Math.PI / 2),
                        );

                        let ok = !b.overlapsRoad(roads);
                        if (ok) ok = !b.overlapsRiver(river);
                        if (ok) {
                            for (const other of buildings) {
                                if (b.overlapsBuilding(other)) {
                                    ok = false;
                                    break;
                                }
                            }
                        }

                        if (ok) buildings.push(b);
                    }
                });
            }

            function generateParks() {
                parks = [];

                const cols = Math.ceil(mapWidth / CFG.gridSize) + 2;
                const rows = Math.ceil(mapHeight / CFG.gridSize) + 2;

                for (let gy = -1; gy < rows; gy++) {
                    for (let gx = -1; gx < cols; gx++) {
                        const seed =
                            ((gx * 73856093) ^
                                (gy * 19349663) ^
                                sessionSeed) >>>
                            0;
                        const cx = gx * CFG.gridSize;
                        const cy = gy * CFG.gridSize;

                        const parkCount =
                            Math.floor(prand(seed + 3000) * 4) + 2;
                        for (let p = 0; p < parkCount; p++) {
                            const s = seed + 3000 + p * 500;
                            if (prand(s) <= 0.2) continue;

                            const x = cx + prand(s + 100) * 110 - 55;
                            const y = cy + prand(s + 200) * 110 - 55;
                            const w = 28 + prand(s + 300) * 46;
                            const h = 24 + prand(s + 400) * 46;
                            const a =
                                (Math.floor(prand(s + 500) * 4) * Math.PI) / 2;

                            const park = new Park(x, y, w, h, a);

                            let ok =
                                x > -w &&
                                x < mapWidth + w &&
                                y > -h &&
                                y < mapHeight + h;

                            if (ok) ok = !park.overlapsRoad(roads);
                            if (ok) ok = !park.overlapsRiver(river);
                            if (ok) ok = !park.overlapsBuildings(buildings);
                            if (ok) {
                                for (const other of parks) {
                                    if (park.overlapsPark(other)) {
                                        ok = false;
                                        break;
                                    }
                                }
                            }

                            if (ok) parks.push(park);
                        }
                    }
                }
            }

            function placeMarkers() {
                markersEl.innerHTML = "";

                const main = document.createElement("div");
                main.className = "marker main";
                main.style.left = "50%";
                main.style.top = "50%";
                main.innerHTML = `
          <div class="main-wrapper">
            <div class="card" role="region" aria-label="Profile">
              <div class="card-inner">
                <h1 class="name">Tobias Merz</h1>
                <div class="role">Senior Developer • GIS / Geodata • Web Mapping</div>
                <p class="tagline">
                  Building fast, reliable web apps and mapping experiences —
                  from geodata pipelines to interactive cartography.
                </p>
                <div class="chips" aria-label="Skills">
                  <span class="chip"><strong>GIS</strong> &amp; Spatial Analysis</span>
                  <span class="chip"><strong>Web Maps</strong> (Vector/Tile)</span>
                  <span class="chip"><strong>APIs</strong> &amp; Data Engineering</span>
                  <span class="chip"><strong>Frontend</strong> Performance</span>
                </div>
                <div class="divider"></div>
                <div class="cta">
                  <button class="btn" id="btn-randomize">
                    <span>Recreate map</span>
                    <span class="kbd">R</span>
                  </button>
                  <button class="btn" id="btn-edit-mode" aria-label="Toggle marker edit mode" style="display: none;">
                    <span id="edit-mode-text">Edit Markers</span>
                    <span class="kbd">E</span>
                  </button>
                  <button class="btn" id="mode-toggle" aria-label="Toggle dark/light mode">
                    <span id="mode-toggle-text">Light Mode</span>
                    <span class="kbd">M</span>
                  </button>
                </div>
                <div class="footer-note">
                  Tip: Move and zoom around the map to explore different areas and find hidden treasures.
                </div>
              </div>
            </div>
          </div>
        `;
                markersEl.appendChild(main);

                const btnRand = main.querySelector("#btn-randomize");
                btnRand.addEventListener("click", (e) => {
                    e.preventDefault();
                    reshuffle();
                });

                const btnMode = main.querySelector("#mode-toggle");
                btnMode.addEventListener("click", toggleMode);

                // Show edit mode button only on desktop
                const btnEditMode = main.querySelector("#btn-edit-mode");
                if (!isMobile) {
                    btnEditMode.style.display = "inline-flex";
                    btnEditMode.addEventListener("click", (e) => {
                        e.preventDefault();
                        toggleEditMode();
                    });
                }

                // Get dynamic exclusion zones
                const mainBounds = getMainCardBounds();
                const legendBounds = getLegendBounds();

                const placed = [
                    { x: mainBounds.centerX, y: mainBounds.centerY },
                ];
                markerPositions = [
                    { x: mainBounds.centerX, y: mainBounds.centerY },
                ];

                // Define the visible initial viewport area in world coordinates
                // The initial camera is centered, so visible area is centered in the map
                const viewportBounds = {
                    minX: (mapWidth - window.innerWidth) / 2,
                    maxX: (mapWidth + window.innerWidth) / 2,
                    minY: (mapHeight - window.innerHeight) / 2,
                    maxY: (mapHeight + window.innerHeight) / 2,
                };

                for (const link of LINKS) {
                    let x = 0;
                    let y = 0;
                    let attempts = 0;

                    while (attempts < 120) {
                        const r =
                            roads[Math.floor(Math.random() * roads.length)];
                        if (!r || !r.path.length) {
                            attempts++;
                            continue;
                        }

                        const p =
                            r.path[Math.floor(Math.random() * r.path.length)];

                        // Only consider roads within or near the visible initial viewport
                        const margin = 200;
                        if (
                            p.x < viewportBounds.minX - margin ||
                            p.x > viewportBounds.maxX + margin ||
                            p.y < viewportBounds.minY - margin ||
                            p.y > viewportBounds.maxY + margin
                        ) {
                            attempts++;
                            continue;
                        }

                        const offset = 110 + Math.random() * 80;
                        const ang = Math.random() * Math.PI * 2;

                        x = p.x + Math.cos(ang) * offset;
                        y = p.y + Math.sin(ang) * offset;

                        // Check if marker is at least somewhat visible (relaxed constraints)
                        if (
                            x < viewportBounds.minX - CFG.markerPadding ||
                            x > viewportBounds.maxX + CFG.markerPadding ||
                            y < viewportBounds.minY - CFG.markerPadding ||
                            y > viewportBounds.maxY + CFG.markerPadding
                        ) {
                            attempts++;
                            continue;
                        }

                        // Check if point is in exclusion zones
                        if (
                            isPointInExclusionZone(
                                x,
                                y,
                                mainBounds,
                                legendBounds,
                            )
                        ) {
                            attempts++;
                            continue;
                        }

                        // Ensure minimum distance from other markers
                        const ok = !placed.some(
                            (m) => dist(m.x, m.y, x, y) < CFG.markerMinDistance,
                        );

                        if (ok) break;

                        attempts++;
                    }

                    if (attempts >= 120) continue;

                    placed.push({ x, y });
                    markerPositions.push({ x, y });

                    const el = document.createElement("div");
                    el.className = "marker";
                    // Store world coordinates as data attributes
                    el.dataset.worldX = x;
                    el.dataset.worldY = y;
                    // Position in screen space with camera offset and zoom
                    const screenX = x * camera.zoom + camera.x;
                    const screenY = y * camera.zoom + camera.y;
                    el.style.left = `${screenX}px`;
                    el.style.top = `${screenY}px`;
                    el.style.transform = `translate(-50%, -100%) scale(${camera.zoom})`;
                    el.innerHTML = `
            <div class="drag-handle">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 2L12 22M12 2L9 5M12 2L15 5M12 22L9 19M12 22L15 19M2 12L22 12M2 12L5 9M2 12L5 15M22 12L19 9M22 12L19 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </div>
            <div class="tooltip">${link.name}</div>
            <a href="${link.url}" target="_blank" rel="noopener" aria-label="${link.name}">
              <div class="pin">
                <div class="pin-icon">${ICONS[link.icon]}</div>
              </div>
            </a>
          `;

                    // Add marker drag event listeners (desktop only)
                    if (!isMobile) {
                        el.addEventListener("mousedown", onMarkerMouseDown);
                    }

                    markersEl.appendChild(el);
                }
            }

            function generateAll() {
                generateRiver();
                generateRoads();
                generateBuildings();
                generateParks();
                placeMarkers();
            }

            function startMapAnimation() {
                isAnimating = true;
                animationStart = Date.now();

                // Calculate bounding box of all markers
                let minX = Infinity;
                let maxX = -Infinity;
                let minY = Infinity;
                let maxY = -Infinity;

                for (const marker of markerPositions) {
                    minX = Math.min(minX, marker.x);
                    maxX = Math.max(maxX, marker.x);
                    minY = Math.min(minY, marker.y);
                    maxY = Math.max(maxY, marker.y);
                }

                // Center of bounding box
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                // Calculate zoom to fit bounding box with padding
                const boxWidth = maxX - minX;
                const boxHeight = maxY - minY;
                const padding = 1.2;

                const zoomX = window.innerWidth / (boxWidth * padding);
                const zoomY = window.innerHeight / (boxHeight * padding);
                const targetZoom = Math.min(zoomX, zoomY, MAX_ZOOM);

                // Calculate camera position to center the bounding box
                const centerScreenX = window.innerWidth / 2;
                const centerScreenY = window.innerHeight / 2;

                const targetCameraX = centerScreenX - centerX * targetZoom;
                const targetCameraY = centerScreenY - centerY * targetZoom;

                animationInitial = { ...camera };
                animationTarget = {
                    x: targetCameraX,
                    y: targetCameraY,
                    zoom: targetZoom,
                };
            }

            function updateAnimation() {
                if (!isAnimating) return;

                const now = Date.now();
                const elapsed = now - animationStart;
                let progress = Math.min(1, elapsed / CFG.animationDuration);

                // Ease out quad
                progress = easeOutQuad(progress);

                camera.x =
                    animationInitial.x +
                    (animationTarget.x - animationInitial.x) * progress;
                camera.y =
                    animationInitial.y +
                    (animationTarget.y - animationInitial.y) * progress;
                camera.zoom =
                    animationInitial.zoom +
                    (animationTarget.zoom - animationInitial.zoom) * progress;

                applyBounds();
                updateMarkerPositions();

                if (progress >= 1) {
                    isAnimating = false;
                }
            }

            // ====== DRAW LOOP ======
            function drawBackdrop() {
                ctx.save();
                ctx.globalCompositeOperation = "screen";
                ctx.strokeStyle = "rgba(255, 255, 255, 0.04)";
                ctx.lineWidth = 1;

                const step = 90;
                for (let x = -mapHeight; x < mapWidth + mapHeight; x += step) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x + mapHeight, mapHeight);
                    ctx.stroke();
                }
                ctx.restore();
            }

            function draw() {
                ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

                if (isDarkMode) {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.08)";
                } else {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.02)";
                }
                ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

                // Apply camera transformation (translate and zoom)
                ctx.save();
                ctx.translate(camera.x, camera.y);
                ctx.scale(camera.zoom, camera.zoom);

                drawBackdrop();

                for (const b of buildings) b.draw(ctx);
                for (const p of parks) p.draw(ctx);
                if (river) river.draw(ctx);
                for (const r of roads) {
                    r.step();
                    r.draw(ctx);
                }

                ctx.restore();

                updateAnimation();

                requestAnimationFrame(draw);
            }

            // ====== INTERACTION ======
            function reshuffle() {
                sessionSeed = Math.random() * 100000;
                generateAll();
                startMapAnimation();
            }

            function toggleMode() {
                isDarkMode = !isDarkMode;
                document.documentElement.classList.toggle("light-mode");
                localStorage.setItem(
                    "theme-mode",
                    isDarkMode ? "dark" : "light",
                );

                // Update button text to show the mode it will switch TO
                const modeToggleText =
                    document.getElementById("mode-toggle-text");
                if (modeToggleText) {
                    modeToggleText.textContent = isDarkMode
                        ? "Light Mode"
                        : "Dark Mode";
                }
            }

            function toggleEditMode() {
                if (isMobile) return;

                isEditMode = !isEditMode;
                const editModeText = document.getElementById("edit-mode-text");
                const btnEditMode = document.getElementById("btn-edit-mode");

                if (isEditMode) {
                    editModeText.textContent = "Done Editing";
                    if (isDarkMode) {
                        btnEditMode.style.background =
                            "rgba(101, 245, 255, 0.15)";
                        btnEditMode.style.borderColor =
                            "rgba(101, 245, 255, 0.4)";
                    } else {
                        btnEditMode.style.background =
                            "rgba(80, 150, 255, 0.2)";
                        btnEditMode.style.borderColor =
                            "rgba(80, 150, 255, 0.5)";
                    }

                    // Show drag handles
                    const markers =
                        markersEl.querySelectorAll(".marker:not(.main)");
                    markers.forEach((marker) => {
                        marker.classList.add("edit-mode");
                    });
                } else {
                    editModeText.textContent = "Edit Markers";
                    btnEditMode.style.background = "";
                    btnEditMode.style.borderColor = "";

                    // Hide drag handles
                    const markers =
                        markersEl.querySelectorAll(".marker:not(.main)");
                    markers.forEach((marker) => {
                        marker.classList.remove("edit-mode");
                    });
                }
            }

            function onKeyDown(e) {
                if (e.key === "r" || e.key === "R") {
                    reshuffle();
                }
                if (e.key === "m" || e.key === "M") {
                    toggleMode();
                }
                if (e.key === "e" || e.key === "E") {
                    toggleEditMode();
                }
            }

            // ====== MARKER DRAGGING ======
            function onMarkerMouseDown(e) {
                if (!isEditMode || isMobile) return;

                const marker = e.target.closest(".marker:not(.main)");
                if (!marker) return;

                // Prevent default to stop link navigation and prevent text selection
                e.preventDefault();
                e.stopPropagation();

                draggedMarker = marker;

                markerDragStart.x = e.clientX;
                markerDragStart.y = e.clientY;

                markerWorldStart.x = parseFloat(marker.dataset.worldX);
                markerWorldStart.y = parseFloat(marker.dataset.worldY);

                // Add visual feedback
                marker.style.opacity = "0.7";
            }

            function onMarkerMouseMove(e) {
                if (!draggedMarker || !isEditMode) return;

                const dx = e.clientX - markerDragStart.x;
                const dy = e.clientY - markerDragStart.y;

                // Convert screen delta to world delta
                const worldDx = dx / camera.zoom;
                const worldDy = dy / camera.zoom;

                // Update world coordinates
                const newWorldX = markerWorldStart.x + worldDx;
                const newWorldY = markerWorldStart.y + worldDy;

                // Update data attributes
                draggedMarker.dataset.worldX = newWorldX;
                draggedMarker.dataset.worldY = newWorldY;

                // Update screen position
                const screenX = newWorldX * camera.zoom + camera.x;
                const screenY = newWorldY * camera.zoom + camera.y;
                draggedMarker.style.left = `${screenX}px`;
                draggedMarker.style.top = `${screenY}px`;
            }

            function onMarkerMouseUp(e) {
                if (draggedMarker) {
                    // Reset visual feedback
                    draggedMarker.style.opacity = "";
                    draggedMarker = null;
                }
            }

            // ====== PANNING ======
            function onMouseDown(e) {
                if (draggedMarker) return;

                if (e.target !== canvas) return;
                isDragging = true;
                dragStart.x = e.clientX;
                dragStart.y = e.clientY;
                dragOffset.x = camera.x;
                dragOffset.y = camera.y;
                canvas.style.cursor = "grabbing";
            }

            function onMouseMove(e) {
                if (draggedMarker) {
                    onMarkerMouseMove(e);
                    return;
                }

                if (!isDragging) return;

                const dx = e.clientX - dragStart.x;
                const dy = e.clientY - dragStart.y;

                // Update camera position
                camera.x = dragOffset.x + dx;
                camera.y = dragOffset.y + dy;

                applyBounds();
                updateMarkerPositions();
            }

            function onMouseUp(e) {
                if (draggedMarker) {
                    onMarkerMouseUp(e);
                }

                isDragging = false;
                canvas.style.cursor = "grab";
            }

            function onTouchStart(e) {
                if (e.target !== canvas) return;

                if (e.touches.length === 2) {
                    // Pinch zoom starting
                    isAnimating = false;
                    isDragging = false;
                    isDraggingMarker = false;
                    lastPinchDistance = getPinchDistance(
                        e.touches[0],
                        e.touches[1],
                    );
                } else if (e.touches.length === 1) {
                    // Single touch pan
                    isAnimating = false;
                    isDragging = true;
                    dragStart.x = e.touches[0].clientX;
                    dragStart.y = e.touches[0].clientY;
                    dragOffset.x = camera.x;
                    dragOffset.y = camera.y;
                }
            }

            function onTouchMove(e) {
                if (e.touches.length === 2) {
                    // Pinch zoom
                    e.preventDefault();

                    const currentDistance = getPinchDistance(
                        e.touches[0],
                        e.touches[1],
                    );
                    if (lastPinchDistance > 0) {
                        const center = getPinchCenter(
                            e.touches[0],
                            e.touches[1],
                        );
                        const rect = canvas.getBoundingClientRect();
                        const centerX = center.x - rect.left;
                        const centerY = center.y - rect.top;

                        // Calculate world position before zoom
                        const worldX = (centerX - camera.x) / camera.zoom;
                        const worldY = (centerY - camera.y) / camera.zoom;

                        // Calculate new zoom
                        const zoomDelta = currentDistance / lastPinchDistance;
                        const newZoom = Math.max(
                            MIN_ZOOM,
                            Math.min(MAX_ZOOM, camera.zoom * zoomDelta),
                        );

                        // Calculate new camera position to keep pinch center stationary
                        camera.x = centerX - worldX * newZoom;
                        camera.y = centerY - worldY * newZoom;
                        camera.zoom = newZoom;

                        applyBounds();
                        updateMarkerPositions();
                    }

                    lastPinchDistance = currentDistance;
                } else if (e.touches.length === 1 && isDragging) {
                    // Single touch pan
                    e.preventDefault();

                    const dx = e.touches[0].clientX - dragStart.x;
                    const dy = e.touches[0].clientY - dragStart.y;

                    camera.x = dragOffset.x + dx;
                    camera.y = dragOffset.y + dy;

                    applyBounds();
                    updateMarkerPositions();
                }
            }

            function onTouchEnd(e) {
                if (e.touches.length < 2) {
                    lastPinchDistance = 0;
                }
                if (e.touches.length === 0) {
                    isDragging = false;
                    isDraggingMarker = false;
                    draggedMarkerIndex = -1;
                }
            }

            function updateMarkerPositions() {
                const markers = markersEl.querySelectorAll(".marker");
                markers.forEach((marker) => {
                    if (marker.classList.contains("main")) return;

                    const worldX = parseFloat(marker.dataset.worldX);
                    const worldY = parseFloat(marker.dataset.worldY);

                    if (!isNaN(worldX) && !isNaN(worldY)) {
                        const screenX = worldX * camera.zoom + camera.x;
                        const screenY = worldY * camera.zoom + camera.y;
                        marker.style.left = `${screenX}px`;
                        marker.style.top = `${screenY}px`;
                        marker.style.transform = `translate(-50%, -100%) scale(${camera.zoom})`;
                    }
                });
            }

            // ====== ZOOMING ======
            function onWheel(e) {
                e.preventDefault();

                isAnimating = false;

                // Get mouse position relative to canvas
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Calculate world position before zoom
                const worldX = (mouseX - camera.x) / camera.zoom;
                const worldY = (mouseY - camera.y) / camera.zoom;

                // Calculate zoom delta
                const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(
                    MIN_ZOOM,
                    Math.min(MAX_ZOOM, camera.zoom * zoomDelta),
                );

                // Calculate new camera position to keep mouse point stationary
                camera.x = mouseX - worldX * newZoom;
                camera.y = mouseY - worldY * newZoom;
                camera.zoom = newZoom;

                // Apply bounds
                applyBounds();
                updateMarkerPositions();
            }

            function getPinchDistance(touch1, touch2) {
                const dx = touch2.clientX - touch1.clientX;
                const dy = touch2.clientY - touch1.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function getPinchCenter(touch1, touch2) {
                return {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2,
                };
            }

            function applyBounds() {
                const scaledWidth = mapWidth * camera.zoom;
                const scaledHeight = mapHeight * camera.zoom;

                camera.x = Math.max(
                    -(scaledWidth - window.innerWidth),
                    Math.min(0, camera.x),
                );
                camera.y = Math.max(
                    -(scaledHeight - window.innerHeight),
                    Math.min(0, camera.y),
                );
            }

            // ====== INIT ======
            function init() {
                // Restore theme from localStorage
                const savedTheme = localStorage.getItem("theme-mode");
                if (savedTheme === "light") {
                    isDarkMode = false;
                    document.documentElement.classList.add("light-mode");
                } else {
                    isDarkMode = true;
                    document.documentElement.classList.remove("light-mode");
                }

                resize();
                generateAll();
                startMapAnimation();
                draw();

                // Update mode toggle button text after DOM is ready
                setTimeout(() => {
                    const modeToggleText =
                        document.getElementById("mode-toggle-text");
                    if (modeToggleText) {
                        modeToggleText.textContent = isDarkMode
                            ? "Light Mode"
                            : "Dark Mode";
                    }
                }, 0);

                // Set cursor style for panning
                canvas.style.cursor = "grab";

                // Add event listeners
                window.addEventListener("resize", () => {
                    resize();
                    generateAll();
                });
                window.addEventListener("keydown", onKeyDown);

                // Mouse events for panning
                canvas.addEventListener("mousedown", onMouseDown);
                window.addEventListener("mousemove", onMouseMove);
                window.addEventListener("mouseup", onMouseUp);

                // Mouse wheel for zooming
                canvas.addEventListener("wheel", onWheel, { passive: false });

                // Touch events for mobile panning and pinch zoom
                canvas.addEventListener("touchstart", onTouchStart, {
                    passive: false,
                });
                canvas.addEventListener("touchmove", onTouchMove, {
                    passive: false,
                });
                canvas.addEventListener("touchend", onTouchEnd);
            }

            init();
        </script>
    </body>
</html>
